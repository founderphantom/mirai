import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database';

// Validate environment variables
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;

if (!supabaseUrl || !supabaseAnonKey || !supabaseServiceKey) {
  throw new Error('Missing Supabase environment variables');
}

// Public client for client-side operations
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
  global: {
    headers: {
      'x-application-name': 'airi-api',
    },
  },
});

// Service role client for admin operations
export const supabaseAdmin = createClient<Database>(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false,
  },
  global: {
    headers: {
      'x-application-name': 'airi-api-admin',
    },
  },
});

// Helper function to get user client with specific access token
export const getSupabaseClient = (accessToken?: string): SupabaseClient<Database> => {
  if (!accessToken) {
    return supabase;
  }

  return createClient<Database>(supabaseUrl, supabaseAnonKey, {
    global: {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'x-application-name': 'airi-api-user',
      },
    },
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
};

// Get a user-scoped Supabase client for secure operations
export const getUserScopedClient = (userId: string, accessToken: string): SupabaseClient<Database> => {
  const client = getSupabaseClient(accessToken);
  
  // This client will respect RLS policies for the authenticated user
  return client;
};

// Security helper to verify user access to resources
export const securityHelpers = {
  // Verify user owns a conversation
  async verifyConversationOwnership(conversationId: string, userId: string): Promise<boolean> {
    const { data, error } = await supabaseAdmin
      .from('conversations')
      .select('id')
      .eq('id', conversationId)
      .eq('user_id', userId)
      .single();
    
    return !error && !!data;
  },

  // Verify user owns a message
  async verifyMessageOwnership(messageId: string, userId: string): Promise<boolean> {
    const { data, error } = await supabaseAdmin
      .from('chat_messages')
      .select('id')
      .eq('id', messageId)
      .eq('user_id', userId)
      .single();
    
    return !error && !!data;
  },

  // Check if user has exceeded rate limits
  async checkUserRateLimits(userId: string): Promise<{
    isAllowed: boolean;
    limit: number;
    remaining: number;
    resetAt: Date;
  }> {
    // Get user's subscription tier
    const profile: any = await dbHelpers.getUserProfile(userId);
    
    // Define limits per tier
    const limits: Record<string, number> = {
      free: 100,
      plus: 500,
      pro: 5000,
      enterprise: -1, // unlimited
    };
    
    const tier = profile?.subscription_tier || 'free';
    const limit = limits[tier];
    
    if (limit === -1) {
      return {
        isAllowed: true,
        limit: -1,
        remaining: -1,
        resetAt: new Date(Date.now() + 3600000),
      };
    }
    
    // Check usage in the last hour
    const isAllowed = await dbHelpers.checkRateLimit(userId, limit);
    const oneHourAgo = new Date(Date.now() - 3600000);
    
    const { count } = await supabaseAdmin
      .from('usage_logs')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .gte('created_at', oneHourAgo.toISOString());
    
    const used = count || 0;
    
    return {
      isAllowed,
      limit,
      remaining: Math.max(0, limit - used),
      resetAt: new Date(Date.now() + 3600000),
    };
  },
};

// Database helper functions
export const dbHelpers = {
  // Get user by ID from auth system
  async getUserById(userId: string) {
    const { data: { user }, error } = await supabaseAdmin.auth.admin.getUserById(userId);
    if (error) throw error;
    return user;
  },

  // Get user profile
  async getUserProfile(userId: string) {
    const { data, error } = await supabaseAdmin
      .from('user_profiles')
      .select('*')
      .eq('id', userId)
      .single();

    if (error) throw error;
    return data;
  },

  // Get user subscription from subscription history
  async getUserSubscription(userId: string) {
    const { data, error } = await supabaseAdmin
      .from('subscription_history')
      .select('*')
      .eq('user_id', userId)
      .eq('status', 'active')
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    return { data, error };
  },

  // Update user profile
  async updateUserProfile(userId: string, updates: any) {
    const { data, error } = await supabaseAdmin
      .from('user_profiles')
      .update({
        ...updates,
        updated_at: new Date().toISOString(),
      })
      .eq('id', userId)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Create conversation with all required fields
  async createConversation(
    userId: string, 
    title: string, 
    modelId: string, 
    providerId: string = 'openai',
    options: {
      systemPrompt?: string;
      temperature?: number;
      maxTokens?: number;
      avatarId?: string;
      voiceId?: string;
      personalityTemplate?: string;
      settings?: any;
    } = {}
  ) {
    const { data, error } = await supabaseAdmin
      .from('conversations')
      .insert({
        user_id: userId,
        title: title || 'New Conversation',
        summary: null,
        model_id: modelId,
        provider_id: providerId,
        avatar_id: options.avatarId || null,
        voice_id: options.voiceId || null,
        personality_template: options.personalityTemplate || null,
        system_prompt: options.systemPrompt || null,
        temperature: options.temperature || 0.7,
        max_tokens: options.maxTokens || 2048,
        settings: options.settings || {},
        tags: [],
        is_archived: false,
        is_starred: false,
        last_message_at: new Date().toISOString(),
        message_count: 0,
        total_tokens_used: 0,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Add message to conversation with all required fields
  async addMessage(
    conversationId: string, 
    role: 'user' | 'assistant' | 'system' | 'function' | 'tool', 
    content: string, 
    userId: string,
    options: {
      contentType?: string;
      promptTokens?: number;
      completionTokens?: number;
      totalTokens?: number;
      modelId?: string;
      providerId?: string;
      attachments?: any[];
      responseTimeMs?: number;
      finishReason?: string;
      functionCall?: any;
      toolCalls?: any[];
      metadata?: any;
    } = {}
  ) {
    const messageData = {
      conversation_id: conversationId,
      user_id: userId,
      role,
      content,
      content_type: options.contentType || 'text',
      attachments: options.attachments || [],
      prompt_tokens: options.promptTokens || 0,
      completion_tokens: options.completionTokens || 0,
      total_tokens: options.totalTokens || 0,
      model_id: options.modelId || null,
      provider_id: options.providerId || null,
      response_time_ms: options.responseTimeMs || null,
      finish_reason: options.finishReason || null,
      flagged_for_moderation: false,
      moderation_results: {},
      function_call: options.functionCall || null,
      tool_calls: options.toolCalls || null,
      rating: null,
      feedback: null,
      metadata: options.metadata || {},
      created_at: new Date().toISOString(),
      edited_at: null,
      deleted_at: null,
    };

    const { data, error } = await supabaseAdmin
      .from('chat_messages')
      .insert(messageData)
      .select()
      .single();

    if (error) throw error;

    // Note: The update_conversation_stats trigger will automatically update
    // message_count, last_message_at, and total_tokens_used in the conversations table

    return data;
  },

  // Soft delete a message
  async softDeleteMessage(messageId: string, userId: string) {
    const { data, error } = await supabaseAdmin
      .from('chat_messages')
      .update({
        deleted_at: new Date().toISOString(),
      })
      .eq('id', messageId)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  // Get conversation messages (excluding soft deleted)
  async getConversationMessages(conversationId: string, limit = 50, beforeId?: string) {
    let query = supabaseAdmin
      .from('chat_messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .is('deleted_at', null)
      .order('created_at', { ascending: true });

    if (beforeId) {
      // Get the timestamp of the before message for cursor pagination
      const { data: beforeMessage } = await supabaseAdmin
        .from('chat_messages')
        .select('created_at')
        .eq('id', beforeId)
        .single();
      
      if (beforeMessage) {
        query = query.lt('created_at', beforeMessage.created_at);
      }
    }

    const { data, error } = await query.limit(limit);

    if (error) throw error;
    return data;
  },

  // Update usage metrics with cost calculation
  async updateUsageMetrics(
    userId: string, 
    promptTokens: number, 
    completionTokens: number, 
    modelId: string, 
    providerId: string,
    endpoint: string = '/api/chat',
    options: {
      responseTimeMs?: number;
      statusCode?: number;
      errorMessage?: string;
      metadata?: any;
    } = {}
  ) {
    const totalTokens = promptTokens + completionTokens;
    
    // Calculate estimated cost based on provider and model
    let estimatedCost = 0;
    if (providerId === 'openai') {
      if (modelId?.includes('gpt-4')) {
        estimatedCost = totalTokens * 0.00003;
      } else if (modelId?.includes('gpt-3.5')) {
        estimatedCost = totalTokens * 0.000002;
      }
    } else if (providerId === 'anthropic') {
      estimatedCost = totalTokens * 0.000025;
    } else {
      estimatedCost = totalTokens * 0.000001;
    }

    const { error } = await supabaseAdmin
      .from('usage_logs')
      .insert({
        user_id: userId,
        endpoint,
        method: 'POST',
        status_code: options.statusCode || 200,
        prompt_tokens: promptTokens,
        completion_tokens: completionTokens,
        total_tokens: totalTokens,
        provider_id: providerId,
        model_id: modelId,
        estimated_cost: estimatedCost,
        response_time_ms: options.responseTimeMs || null,
        error_message: options.errorMessage || null,
        error_code: options.errorMessage ? 'API_ERROR' : null,
        metadata: options.metadata || {},
        created_at: new Date().toISOString(),
      });

    if (error) throw error;

    // Update daily aggregates
    await this.updateDailyAggregates(userId, {
      messageCount: 1,
      promptTokens,
      completionTokens,
      totalTokens,
      estimatedCost,
      providerId,
      modelId,
    });
  },

  // Update daily usage aggregates
  async updateDailyAggregates(
    userId: string,
    updates: {
      messageCount?: number;
      promptTokens?: number;
      completionTokens?: number;
      totalTokens?: number;
      estimatedCost?: number;
      providerId?: string;
      modelId?: string;
    }
  ) {
    const today = new Date().toISOString().split('T')[0];
    
    // Try to update existing record first
    const { data: existing } = await supabaseAdmin
      .from('usage_daily_aggregates')
      .select('*')
      .eq('user_id', userId)
      .eq('date', today)
      .single();

    if (existing) {
      // Update existing record
      const providerUsage = existing.provider_usage || {};
      const modelUsage = existing.model_usage || {};
      
      if (updates.providerId) {
        providerUsage[updates.providerId] = (providerUsage[updates.providerId] || 0) + 1;
      }
      if (updates.modelId) {
        modelUsage[updates.modelId] = (modelUsage[updates.modelId] || 0) + 1;
      }

      await supabaseAdmin
        .from('usage_daily_aggregates')
        .update({
          message_count: existing.message_count + (updates.messageCount || 0),
          total_prompt_tokens: existing.total_prompt_tokens + (updates.promptTokens || 0),
          total_completion_tokens: existing.total_completion_tokens + (updates.completionTokens || 0),
          total_tokens: existing.total_tokens + (updates.totalTokens || 0),
          total_estimated_cost: existing.total_estimated_cost + (updates.estimatedCost || 0),
          provider_usage: providerUsage,
          model_usage: modelUsage,
          updated_at: new Date().toISOString(),
        })
        .eq('id', existing.id);
    } else {
      // Create new record
      const providerUsage = updates.providerId ? { [updates.providerId]: 1 } : {};
      const modelUsage = updates.modelId ? { [updates.modelId]: 1 } : {};

      await supabaseAdmin
        .from('usage_daily_aggregates')
        .insert({
          user_id: userId,
          date: today,
          message_count: updates.messageCount || 0,
          conversation_count: 0,
          total_prompt_tokens: updates.promptTokens || 0,
          total_completion_tokens: updates.completionTokens || 0,
          total_tokens: updates.totalTokens || 0,
          total_estimated_cost: updates.estimatedCost || 0,
          provider_usage: providerUsage,
          model_usage: modelUsage,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        });
    }
  },

  // Check rate limit
  async checkRateLimit(userId: string, limit: number): Promise<boolean> {
    const oneHourAgo = new Date(Date.now() - 3600000).toISOString();
    
    const { count, error } = await supabaseAdmin
      .from('usage_logs')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .gte('created_at', oneHourAgo);

    if (error) throw error;
    return (count || 0) < limit;
  },

  // Log API request
  async logApiRequest(userId: string, endpoint: string, method: string, statusCode: number) {
    const { error } = await supabaseAdmin
      .from('usage_logs')
      .insert({
        user_id: userId,
        endpoint,
        method,
        status_code: statusCode,
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0,
        estimated_cost: 0,
        created_at: new Date().toISOString(),
      });

    if (error) console.error('Failed to log API request:', error);
  },

  // Get user usage summary using RPC function
  async getUserUsageSummary(
    userId: string,
    startDate?: Date,
    endDate?: Date
  ) {
    const { data, error } = await supabaseAdmin.rpc('get_user_usage_stats', {
      p_user_id: userId,
      p_start_date: startDate?.toISOString().split('T')[0] || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      p_end_date: endDate?.toISOString().split('T')[0] || new Date().toISOString().split('T')[0],
    });

    if (error) throw error;
    return data;
  },

  // Search messages across all conversations
  async searchMessages(
    userId: string,
    query: string,
    limit: number = 20,
    offset: number = 0
  ) {
    const { data, error } = await supabaseAdmin.rpc('search_messages', {
      p_user_id: userId,
      p_query: query,
      p_limit: limit,
      p_offset: offset,
    });

    if (error) throw error;
    return data;
  },

  // Get conversations with last message using optimized RPC
  async getConversationsWithLastMessage(
    userId: string,
    limit: number = 20,
    offset: number = 0,
    includeArchived: boolean = false
  ) {
    const { data, error } = await supabaseAdmin.rpc('get_conversations_with_last_message', {
      p_user_id: userId,
      p_limit: limit,
      p_offset: offset,
      p_include_archived: includeArchived,
    });

    if (error) throw error;
    return data;
  },

  // Get conversation messages using optimized RPC
  async getConversationMessagesRPC(
    conversationId: string,
    userId: string,
    limit: number = 50,
    beforeId?: string
  ) {
    const { data, error } = await supabaseAdmin.rpc('get_conversation_messages', {
      p_conversation_id: conversationId,
      p_user_id: userId,
      p_limit: limit,
      p_before_id: beforeId || null,
    });

    if (error) throw error;
    return data;
  },

  // Get conversation summary with token usage
  async getConversationSummary(conversationId: string, userId: string) {
    const { data, error } = await supabaseAdmin.rpc('get_conversation_summary', {
      p_conversation_id: conversationId,
      p_user_id: userId,
    });

    if (error) throw error;
    return data;
  },

  // Archive old conversations
  async archiveOldConversations(userId: string, daysInactive: number = 30) {
    const { data, error } = await supabaseAdmin.rpc('archive_old_conversations', {
      p_user_id: userId,
      p_days_inactive: daysInactive,
    });

    if (error) throw error;
    return data;
  },

  // Export conversation as JSON
  async exportConversationJSON(conversationId: string, userId: string) {
    const { data, error } = await supabaseAdmin.rpc('export_conversation_json', {
      p_conversation_id: conversationId,
      p_user_id: userId,
    });

    if (error) throw error;
    return data;
  },
};

// Real-time subscriptions helper
export const realtimeHelpers = {
  // Subscribe to conversation updates
  subscribeToConversation(conversationId: string, callback: (payload: any) => void) {
    return supabase
      .channel(`conversation:${conversationId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'chat_messages',
          filter: `conversation_id=eq.${conversationId}`,
        },
        callback
      )
      .subscribe();
  },

  // Subscribe to user notifications
  subscribeToUserNotifications(userId: string, callback: (payload: any) => void) {
    return supabase
      .channel(`user:${userId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'notifications',
          filter: `user_id=eq.${userId}`,
        },
        callback
      )
      .subscribe();
  },

  // Unsubscribe from channel
  unsubscribe(channel: any) {
    return supabase.removeChannel(channel);
  },
};

export default supabase;